{"version":3,"sources":["components/AppBar.tsx","config/config.ts","store/search/searchEffects.ts","store/search/searchActions.ts","components/Paginator.tsx","components/VideoSearchResult.tsx","components/Spinner.tsx","screens/SearchScreen.tsx","App.tsx","store/search/searchReducer.ts","store/index.ts","index.tsx"],"names":["AppBar","styles","this","props","className","style","children","React","CONFIG","API_URL","searchYoutube","searchTerm","a","url","replace","fetch","response","json","result","items","map","item","id","videoId","title","snippet","thumbnails","TYPES","Paginator","state","currentPage","goToPage","setState","window","scrollTo","itemsPerPage","beginIndex","slice","component","key","totalItems","pages","Math","ceil","elements","i","page","element","onClick","goToPageWrapper","push","itemsElement","getItemsToDisplay","paginationElements","getPaginationElements","length","ImagePlaceholder","viewBox","xmlns","VideoSearchResult","imageLoaded","youtubeLink","vidoeImage","medium","href","target","src","dangerouslySetInnerHTML","__html","Spinner","SearchScreen","handleSearchTermChanged","event","value","handleKeyPressed","searchVideos","isLoading","isError","results","content","getContent","justifyContent","type","placeholder","onChange","onKeyPress","size","color","connect","searchState","search","searchResults","dispatch","payload","searchActions","getState","searchEffect","App","INITIAL_STATE","reducer","action","store","createStore","reducerMap","searchReducer","combineReducers","rootReducer","applyMiddleware","thunk","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1920d9ef.chunk.js","sourcesContent":["import * as React from 'react';\nimport './AppBar.css';\n\ninterface Props {\n  styles?: React.CSSProperties;\n}\n\n/**\n * App bar at the top of the page.\n */\nexport default class AppBar extends React.Component<Props> {\n  render() {\n    const styles = this.props.styles || {};\n    return (\n      <div className='app-bar' style={styles}>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n","export const CONFIG = {\n  YOUTUBE_API_KEY: 'AIzaSyCX6NjWqI6vPMRmD2OTWz1ldh2Y9JmFFdo'\n}\n","\nimport { CONFIG } from '../../config/config';\nconst SEARCH_TERM = 'SEARCH_TERM';\nconst API_KEY = 'API_KEY'\nconst API_URL = 'https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=30&type=video&q=' + SEARCH_TERM + '&key=' + API_KEY\n\n/**\n * Search youtube for videos and format result\n * @param searchTerm string to search for\n */\nexport async function searchYoutube(searchTerm: string): Promise<Array<YoutubeResult>> {\n  const url = API_URL\n    .replace(API_KEY, CONFIG.YOUTUBE_API_KEY)\n    .replace(SEARCH_TERM, searchTerm);\n\n  const response = await fetch(url);\n  const result = await response.json();\n\n  const items: Array<RawYoutubeResult> = result.items;\n  return items.map((item) => {\n    return {\n      id: item.id.videoId,\n      videoId: item.id.videoId,\n      title: item.snippet.title,\n      thumbnails: item.snippet.thumbnails,\n    }\n  });\n}\n\nexport interface YoutubeResult {\n  id: string;\n  videoId: string;\n  title: string;\n  thumbnails: {\n    default: ThumbnailDetails;\n    medium: ThumbnailDetails;\n    high: ThumbnailDetails;\n  };\n}\n\ninterface RawYoutubeResult {\n  id: {\n    kind: string;\n    videoId: string;\n  };\n  snippet: {\n    title: string;\n    thumbnails: {\n      default: ThumbnailDetails;\n      medium: ThumbnailDetails;\n      high: ThumbnailDetails;\n    }\n  };\n}\n\ninterface ThumbnailDetails {\n  url: string;\n  width: number;\n  height: number;\n}\n","import * as searchEffect from './searchEffects';\nimport { State } from '../store';\n\n// Action types\nconst UPDATE_SEARCH_TERM = 'UPDATE_SEARCH_TERM';\nconst UPDATE_SEARCH_RESULTS = 'UPDATE_SEARCH_RESULTS';\nconst REQUEST_VIDEOS = 'REQUEST_VIDEOS';\nconst REQUEST_VIDEOS_ERROR = 'REQUEST_VIDEOS_ERROR';\n\nexport const TYPES = {\n  UPDATE_SEARCH_TERM: UPDATE_SEARCH_TERM as typeof UPDATE_SEARCH_TERM,\n  UPDATE_SEARCH_RESULTS: UPDATE_SEARCH_RESULTS as typeof UPDATE_SEARCH_RESULTS,\n  REQUEST_VIDEOS: REQUEST_VIDEOS as typeof REQUEST_VIDEOS,\n  REQUEST_VIDEOS_ERROR: REQUEST_VIDEOS_ERROR as typeof REQUEST_VIDEOS_ERROR,\n}\n\n// Typed action obejcts\nexport type Actions = ReturnType<typeof updateSearchTerm> |\n  ReturnType<typeof updateSearchResults> |\n  ReturnType<typeof requestingVideos> |\n  ReturnType<typeof updateSearchError>\n  ;\n\n/**\n * Action to update search term in the store\n * @param searchTerm search term to update to\n */\nexport function updateSearchTerm(searchTerm: string) {\n  return {\n    type: UPDATE_SEARCH_TERM as typeof UPDATE_SEARCH_TERM,\n    payload: searchTerm,\n  }\n}\n\n/**\n * Update search results\n * @param searchResults search results to update\n */\nexport function updateSearchResults(searchResults: Array<searchEffect.YoutubeResult>) {\n  return {\n    type: UPDATE_SEARCH_RESULTS as typeof UPDATE_SEARCH_RESULTS,\n    payload: searchResults\n  }\n}\n\n/**\n * Signal the store that videos are being requested\n */\nexport function requestingVideos() {\n  return {\n    type: REQUEST_VIDEOS as typeof REQUEST_VIDEOS,\n  }\n}\n\n/**\n * Update the store with error.\n */\nexport function updateSearchError() {\n  return {\n    type: REQUEST_VIDEOS_ERROR as typeof REQUEST_VIDEOS_ERROR,\n  }\n}\n\n/**\n * Search for videos\n *\n * Perform search only when:\n *  - a search term is available\n *  - not performing another search\n *  - the search term has not already been searched\n */\nexport function doSearch() {\n  return async (dispatch: Dispatch, getState: () => State) => {\n    const searchState = getState().search;\n    const searchTerm = searchState.searchTerm;\n\n    if (searchTerm && !searchState.isLoading && !searchState.searchResults[searchTerm]) {\n      dispatch(requestingVideos());\n\n      let result: Array<searchEffect.YoutubeResult>;\n      try {\n        result = await searchEffect.searchYoutube(searchTerm);\n        dispatch(updateSearchResults(result));\n      } catch (e) {\n        dispatch(updateSearchError())\n      }\n    }\n  };\n}\n","import * as React from 'react';\nimport './Paginator.css';\n\ninterface Props<T> {\n  styles?: React.CSSProperties;\n  itemsPerPage: number;\n  items: Array<T>;\n  component: React.ComponentClass<{ item: T }>;\n}\n\ninterface OwnState {\n  currentPage: number;\n}\n\n/**\n * Handles pagination logic of a list\n */\nexport default class Paginator<T extends { id: number | string }> extends React.Component<Props<T>, OwnState> {\n\n  constructor(props: Props<T>) {\n    super(props);\n\n    this.state = {\n      currentPage: 1,\n    }\n  }\n\n  /**\n   * Navigate to a page\n   * @param goToPage page number to go to\n   * @returns {Function} call the returned function to go to the page\n   */\n  goToPageWrapper(goToPage: number) {\n    return () => {\n\n      if (this.state.currentPage !== goToPage) {\n\n        this.setState({\n          ...this.state,\n          currentPage: goToPage,\n        });\n        window.scrollTo(0, 0);\n      }\n    }\n  }\n\n  /**\n   * Get items to display on the page from the full list\n   * @param items list of all items\n   * @param itemsPerPage items to display\n   * @param currentPage current page number\n   * @returns {Array<Element>} List of elements to display\n   */\n  getItemsToDisplay(items: Array<T>, itemsPerPage: number, currentPage: number) {\n\n    const beginIndex = (currentPage - 1) * itemsPerPage;\n    return items\n      .slice(beginIndex, beginIndex + itemsPerPage)\n      .map((item) => {\n        return <this.props.component item={item} key={item.id}></this.props.component>\n      });;\n  }\n\n  /**\n   * Get elements for pagination section\n   * @param totalItems total number of items\n   * @param itemsPerPage number of items per page\n   * @param currentPage current page number\n   * @returns {Array<Element>} pagination information to display\n   */\n  getPaginationElements(totalItems: number, itemsPerPage: number, currentPage: number) {\n\n    const pages = Math.ceil(totalItems / itemsPerPage);\n    let elements = [];\n    for (let i = 0; i < pages; i++) {\n\n      const page = i + 1;\n      let className = 'page-number';\n      if (page === currentPage) {\n        className = className + ' current-page'\n      } else {\n        className = className + ' cliclable-page-number'\n      }\n\n      const element = <div className={className} onClick={this.goToPageWrapper(page)} key={page}>{page}</div>\n      elements.push(element);\n    }\n    return elements;\n  }\n\n  render() {\n\n    const items = this.props.items;\n    const itemsPerPage = this.props.itemsPerPage;\n    const currentPage = this.state.currentPage;\n\n    const itemsElement = this.getItemsToDisplay(items, itemsPerPage, currentPage);\n    const paginationElements = this.getPaginationElements(items.length, itemsPerPage, currentPage);\n\n    const styles = this.props.styles || {};\n    return (\n      <div className='paginator' style={styles}>\n        <div className='items'>\n          {itemsElement}\n        </div>\n        <div className='pagination'>\n          {paginationElements}\n        </div>\n      </div>\n    );\n  }\n}\n","import * as React from 'react';\nimport './VideoSearchResult.css';\nimport { YoutubeResult } from '../store/search/searchEffects';\n\n/**\n * A placeholder to take up space before the image loads.\n */\nconst ImagePlaceholder = function () {\n  return <svg viewBox=\"0 0 320 180\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n}\n\ninterface Props {\n  item: YoutubeResult\n}\n\n/**\n * Renders a single video result\n */\nexport default class VideoSearchResult extends React.Component<Props> {\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      imageLoaded: false\n    };\n  }\n\n  render() {\n    const YOUTUBE_LINK_PREFIX = 'https://www.youtube.com/watch?v=';\n    const youtubeLink = YOUTUBE_LINK_PREFIX + this.props.item.videoId;\n    const title = this.props.item.title;\n    const vidoeImage = this.props.item.thumbnails.medium.url;\n\n    return (\n\n      <div className='video-search-result'>\n        <a className='youtube-link' href={youtubeLink} target='_blank'>\n          <div className='image-container'>\n            <img className='video-image' src={vidoeImage}></img>\n            <div className='video-image-placeholder' ><ImagePlaceholder /></div>\n          </div>\n          <div className='video-title' dangerouslySetInnerHTML={{ __html: title }}></div>\n        </a>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport './Spinner.css';\n\n/**\n * Displays a spinner\n */\nexport default function Spinner() {\n  return (\n    <div className=\"spinner la-ball-beat la-dark\">\n      <div></div>\n      <div></div>\n      <div></div>\n    </div>\n  );\n}\n","import * as React from 'react';\nimport { connect } from 'react-redux';\nimport './SearchScreen.css';\nimport AppBar from '../components/AppBar';\nimport { IoIosSearch } from 'react-icons/io';\nimport * as searchActions from '../store/search/searchActions';\nimport Paginator from '../components/Paginator';\nimport VideoSearchResult from '../components/VideoSearchResult';\nimport { YoutubeResult } from '../store/search/searchEffects';\nimport { State } from '../store/store';\nimport Spinner from '../components/Spinner';\n\ninterface StateProps {\n  searchTerm: string;\n  results: Array<YoutubeResult>;\n  isError: boolean;\n  isLoading: boolean;\n}\n\ninterface DispatchProps {\n  searchVideos: (searchTerm: string) => void;\n}\n\ntype Props = StateProps & DispatchProps\ninterface OwnState {\n  searchTerm: string\n}\n\n/**\n * Display the screen to search videos\n */\nexport class SearchScreen extends React.Component<Props, OwnState> {\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      searchTerm: ''\n    }\n  }\n\n  /**\n   * Update state when user updates the search term\n   */\n  handleSearchTermChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({\n      searchTerm: event.target.value\n    })\n  }\n\n  /**\n   * Detect for enter pressed to search video\n   */\n  handleKeyPressed = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === \"Enter\") {\n      this.searchVideos()\n    }\n  }\n\n  /**\n   * Search video\n   */\n  searchVideos = () => {\n    this.props.searchVideos(this.state.searchTerm);\n  }\n\n  /**\n   * Get content to display. This could be a message a list of video results\n   */\n  getContent() {\n    let content;\n    if (this.props.isLoading) {\n      content = <div className='search-screen-info'><Spinner></Spinner></div>\n    } else if (this.props.isError) {\n      content = <div className='search-screen-info'>An error occurred. Please try again later.</div>\n    } else if (this.props.searchTerm) {\n      if (this.props.results.length === 0) {\n        content = <div className='search-screen-info'>No results</div>\n      } else {\n        content = <Paginator items={this.props.results} itemsPerPage={10} component={VideoSearchResult}></Paginator>\n      }\n    } else {\n      content = <div className='search-screen-info'>Start by typing something in the input above!</div>\n    }\n    return content;\n  }\n\n  render() {\n\n    const content = this.getContent();\n    return (\n      <div className='search-screen'>\n        <AppBar styles={{ justifyContent: 'center' }}>\n          <input\n            type='text'\n            className='search-input'\n            value={this.state.searchTerm}\n            placeholder='Search...'\n            onChange={this.handleSearchTermChanged}\n            onKeyPress={this.handleKeyPressed}\n          >\n          </input>\n          <div className='icon-container'>\n            <IoIosSearch size='32' color='#fff' className='search-icon' onClick={this.searchVideos} />\n          </div>\n        </AppBar>\n        <div className='search-results'>\n          {content}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport function mapStateToProps(state: State): StateProps {\n  const searchState = state.search;\n\n  return {\n    searchTerm: searchState.searchTerm,\n    results: searchState.searchResults[searchState.searchTerm] || [],\n    isError: searchState.isError,\n    isLoading: searchState.isLoading,\n  };\n}\n\nexport function mapDispatchToProps(dispatch: Dispatch): DispatchProps {\n  return {\n    searchVideos: (searchTerm: string) => {\n      dispatch(searchActions.updateSearchTerm(searchTerm));\n      dispatch(searchActions.doSearch());\n    }\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SearchScreen);\n","import React from 'react';\nimport './App.css';\nimport SearchScreen from './screens/SearchScreen';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SearchScreen></SearchScreen>\n    </div>\n  );\n}\n\nexport default App;\n","\nimport { Actions, TYPES } from './searchActions';\nimport { YoutubeResult } from './searchEffects';\n\ninterface State {\n  searchTerm: string;\n  searchResults: {\n    [key: string]: Array<YoutubeResult>\n  },\n  isLoading: boolean;\n  isError: boolean;\n}\n\nconst INITIAL_STATE: State = {\n  searchTerm: '',\n  searchResults: {},\n  isLoading: false,\n  isError: false,\n}\n\nexport default function reducer(state: State = INITIAL_STATE, action: Actions) {\n  switch (action.type) {\n\n    case TYPES.UPDATE_SEARCH_TERM:\n      return {\n        ...state,\n        searchTerm: action.payload,\n      };\n\n    case TYPES.UPDATE_SEARCH_RESULTS:\n      return {\n        ...state,\n        searchResults: {\n          ...state.searchResults,\n          [state.searchTerm]: action.payload,\n        },\n        isLoading: false,\n      };\n\n    case TYPES.REQUEST_VIDEOS:\n      return {\n        ...state,\n        isError: false,\n        isLoading: true,\n      };\n\n    case TYPES.REQUEST_VIDEOS_ERROR:\n      return {\n        ...state,\n        isError: true,\n        isLoading: false,\n      };\n    default:\n  }\n  return state;\n};\n","import searchReducer from './search/searchReducer';\nimport thunk from 'redux-thunk';\nimport { combineReducers, createStore, applyMiddleware } from 'redux';\n\nfunction rootReducer() {\n  const reducerMap = {\n    search: searchReducer,\n  };\n\n  return combineReducers(reducerMap);\n};\n\n\nconst store = createStore(rootReducer(), applyMiddleware(thunk));\n\nexport default store;\n","/// <reference path=\"./type-declarations.d.ts\" />\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { Provider } from 'react-redux'\nimport store from './store';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}